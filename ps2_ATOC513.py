"""
ps2_ATOC513.py

Author: Devon Gulley

Completion date: (ongoing)

The objectives of this work are to illustrate the Rossby adjustment problem  as follows:
    - Compute the Fourier sums each of (u,v,phi) for geostrophic and Poincare plane waves
    - Graph this time evolution using a Hovmoller plot and the tendency to evolve towards geostropohy
    - Calculate the available potential energy generated by each wave
    - Decomposes the total energy to determine the contributions from each mode
"""
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation


"""Constants and problem setup"""
n_max = 100 #the number of Fourier terms
epsilon = 0.025 #chosen ratio between deformation and characteristic radius
L = 1 #characteristic length scale
L_d = epsilon*L #deformation radius
k_d = np.ones(n_max)/L_d #constant wavevector associated with deformation radius
aspectRatio = 10**3 #L/H
H = L/aspectRatio #taking H to be much smaller than L
x = np.linspace(start = -0.5*L, stop = 0.5*L, num = 1000)
g = 10#arbitrary gravitational constant
n0 = 1.5/epsilon
f = np.sqrt(g*H)/L_d #f-plane approximation


"""Wave generation variables and functions"""
#For the nth sample in the Fourier series
n = np.ones(n_max)*range(n_max)

#A_n for the Gaussian pulse Fourier coefficients
A_0 = 2*epsilon*np.pi**0.5
A = A_0*np.exp(-1*(epsilon*np.pi*n)**2)

#Wave vector
k = n*2*np.pi/L



#(Positive) Poincare dispersion relationship
omega = np.sqrt(g*k +np.ones(n_max)*f**2)


"""
function wave(x_,t_,dispersion,phase)

    Returns the wave function with a given dispersion method at a specified time.

        dispersion:
            +1 or -1 for corresponding Poincare modes, 0 for geostrophy.

        phase:
            Shift in radians which can allows asymetrical wave representations about zero.
"""
def wave(x_,t_=0,dispersion = 0,type = 'phi'):

    #Each kind of wave in (u,v,phi) has different properties set here
    phase = 0
    freqScale = np.ones(n_max)
    match type:
        case 'phi':#for this problem this is the most simplistic base case
            phase = 0
            freqScale = np.ones(n_max)

        case 'u':
            phase = 0
            freqScale = omega/(g*H)

        case 'v':
            phase = np.pi/2
            freqScale = np.ones(n_max)*(f/(g*H))


    t_ = np.ones(len(x_))*t_
    phase = np.ones(len(x_))*phase

    #Geostrophic modes are associated with a K_d^2/(K_n^2 +K_d^2) and zero dispersion
    if(dispersion==0):#The geostrophic case, checking for zero cases is just for performance 
        if(phase[0] ==0):
            return sum((k_d[0]**2/(k[n]**2 + k_d[0]**2))*A[n]*np.cos(k[n]*x_) for n in range(1,n_max))
        return sum((k_d[0]**2/(k[n]**2 + k_d[0]**2))*A[n]*np.cos(k[n]*x_ -phase) for n in range(1,n_max))


    #Poinare Modes are associated with a K_n^2/(K_n^2+K_d^2) coeficients
    return 0.5*sum((k[n]**2/(k[n]**2 + k_d[0]**2))*A[n]*np.cos(k[n]*x_ - dispersion*omega[n]*t_-phase) for n in range(1,n_max))

#plt.plot(x,wave(x,0,-1))
#plt.show()


speed = 1/1000
displayHeight = 2.0
def animate(t):
    t = t*speed
    ax.cla()
    waveType = 'v'

    y_plus = wave(x,t,1,waveType)
    y_minus = wave(x,t,-1, waveType)
    y_g = wave(x,t,0, waveType)
    y_total = y_plus + y_minus + y_g

    plt.plot(x,y_plus)
    plt.plot(x,y_minus)
    plt.plot(x,y_g)
    plt.plot(x,y_total,c='red')

    view =displayHeight
    plt.legend(["+poincare","-poincare","geostrophy","overall"])
    ax.set_ylim(0-view,0+view)

#Displaying animated figures
fig = plt.figure()
ax = fig.add_subplot()
ani = animation.FuncAnimation(fig,animate,frames= 1200,interval = 1)
plt.show()

